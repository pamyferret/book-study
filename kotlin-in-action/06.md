# 코틀린 타입 시스템
## 널 가능성
null이 될 수 있는 타입은 뒤에 ?를 붙인다.
```
String?
Int?
CustomType?
```
널이 될 수 있는 값을 넣이 될 수 없는 타입의 변수에 대입할 수 없다.

null이 아님이 확실한 영역에서는 널이 될 수 없는 타입처럼 사용할 수 있다.
```
fun strLenSafe(s: String?): Int =
  if (s != null) s.length else 0
```
## 타입의 의미
실행 시점에 널이 될 수 있는 타입이나 널이 될 수 없는 타입의 객체는 같게 취급된다.
널이 될 수 있는 타입은 널이 될 수 없는 타입을 감싼 래퍼 타입이 아니라 컴파일 시점에 null 검사가 이뤄지냐 차이다.
따라서 코틀린에서는 널이 될 수 있는 타입을 처리하는데 실행 시점에 별도의 부가 비용이 들지 않는다.

## 안전한 호출 연산자: ?
?.은 null 검사와 메서드 호출을 한 번의 연산으로 수행한다.

## 엘비스 연산자: ?:
앨비스 연산자를 통해서 null 대신 사용할 디폴트 값을 지정할 수 있다.

## 안전한 캐스트: as?
as? 연산자는 어떤 값을 지정한 타입으로 캐스트한다.
as?는 값을 대상 타입으로 변환할 수 없으면 null을 반환한다.
```
foo as? Type
>> foo is Type 일 경우 Type으로 cast
>> foo !is Type 일 경우 null
```

## 널 아님 단언: !!
!!를 사용하면 어떤 값이든 널이 될 수 없는 타입으로 강제로 바꿀 수 있다.
실제 널에 대해 !!를 적용하면 NPE가 발생한다.
따라서 NPE가 발생할 때 stack trace에 몇 번째 줄인지 정보 정확성을 위해서 여러 !!를 한 줄에 쓰는 일은 피하는게 좋다.
```
person.company!!.address!!.country
```

## let 함수
let 함수는 자신의 수신 객체를 인자로 전달 받은 람다에게 넘긴다.
```
foo?. let {
 // foo이 null이 아닐 경우 안의 코드가 동작한다.
 // 내부에서 수신 객체를 it으로 사용할 수 있다.
}
```

## 나중에 초기화할 프로퍼티
lateinit 변경자를 붙이면 프로퍼티를 나중에 초기화 할 수 있다.
나중에 초기화하는 프로퍼티는 항상 var여야 한다.
val 프로퍼티는 final 필드로 컴파일 되어 생성자 안에서 반드시 초기화 되어야 한다.

## 널이 될 수 있는 타입 확장
코틀린에서는 널이 될 수 있는 타입의 확장 함수 안에서는 this가 null이 될 수 있다는 점이 자바와 다르다.
확장 함수: isNullOrBlank(), isNullOfEmpty()

## 타입 파라미터의 널 가능성
타입 파라미터인 T는 이름 끝에 물음표가 없더라도 널이 될 수 있는 타입이다.
```
fun <T> printHashCode(t: T) {
  println(t?.hashCode())
}
```

널이 될 수 없는 타입으로 정의하고 싶으면 타입 상한(upper bound)를 정의해야 한다.
```
fun <T: Any> printHashCode(t: T) { // 널이 아닌 타입 Any를 정의 했으므로 T는 널이 될 수 없는 타입이다.
  println(t.hashCode())
}
```

## 널 가능성과 자바
코틀린은 @Nullable, @NotNull 어노테이션이 붙은 자바 타입을 어노테이션에 따라 널이 될 수 있는 타입이나 널이 될 수 없는 타입으로 취급한다.
이런 널 가능성 어노테이션이 없는 경우에는 코틀린의 플랫폼 타입이 된다.

### 플랫폼 타입
코틀린이 널 관련 정보를 알 수 없는 타입을 말한다.
코틀린에서 플랫폼 타입을 따로 선언해 사용할 수는 없고 자바 코드에서 가져온 타입이 자동으로 플랫폼 타입이 될 뿐이다.
하지만 컴파일 오류 메시지에서는 플랫폼 타입을 볼 수 있다.
```
ERROR: Type mismatch: inferred type is String! but Int was expected
// 뒤에 !가 붙은 String!이 플랫폼 타입니다.
```

### 상속
코틀린에서 자바 메서드를 오버라디으할 때 그 메서드의 파라미터와 반환 타입을 넣이 될 수 있는 타입으로 선언할지 널이 될 수 없는 타입으로 선언할지 선택할 수 있다.

## 코틀린의 원시 타입
코틀린은 원시 타입과 래퍼 타입을 구분하지 않는다.

### 원시 타입: Int, Boolean 등
코틀린에서는 실행 시점에 숫자 타입은 가능한 한 가장 효율적인 방식으로 표현된다.
예를 들어 코틀린의 Int 타입은 자바의 래퍼 타입인 Integer가 아닌 원시 타입인 int로 컴파일 된다.
자바 원시 타입에 해당하는 타입은 다음과 같다.
* 정수 타입: Byte, Short, Int, Long
* 부동 소수점 수 타입: Float, Double
* 문자 타입: Char
* 불리언 타입: Boolean

### 널이 될 수 있는 원시 타입: Int?, Boolean? 등
코틀린에서 널이 될 수 있는 원시 타입을 사용하면 그 타입은 자바의 래퍼 타입으로 컴파일 된다.

### 숫자 변환
코틀린은 산 타입의 숫자를 다른 타입의 숫자로 자동 변환하지 않는다.
```
val i = 1
val l: Long = i // ERROR: Type mismatch 컴파일 오류 발생
```

대신 코틀린은 모든 원시 타입에 대해 변환 함수를 제공한다. (toByte(), toShort(), toChar() 등)
추가로 산술 연산자는 적당한 타입의 값을 받아들일 수 있게 이미 오버로드 되어 있다.
```
fun foo(l: Long) = println(l)
val b: Byte = 1
val l = b + 1L
foo(42)
```

### Any, Any?: 최상위 타입
코틀린에서는 Any가 Int등의 원시 타입을 포함한 모든 타입의 조상 타입니다.
자바 메서드에서 Object를 인자로 받거나 반환하면 코틀린에서는 Any로 그 타입을 취급한다.

### Unit 타입: 코틀린의 void
코틀린의 Unit 타입은 자바 void와 같은 기능을 한다.

### Nothing 타입: 이 함수는 결코 정상적으로 끝나지 않는다.
fail이라는 특별한 메시지가 들어 있는 예외를 던져서 테스트 실패 시키거나 무한 루프 도는 함수 등 함수가 정상적으로 끝나지 않는 경우를 나타내기 위해 Nothing이라는 반환 타입을 사용한다.
Nothing은 함수의 반환 타입이나 반환 타입으로 쓰일 타입 파라미터로만 쓸 수 있다.

## 컬렉션과 배열
### 널 가능성과 컬렉션
filterNotNull()을 통해 null 값을 걸러준다.

### 읽기 전용과 변경 가능한 컬렉션
Collection vs MutableCollection
읽기 전용 컬렉션을 변경 가능 컬렉션으로 변경해 변경할 수 있으므로 읽기 전용 컬렉션이 항상 쓰레드 안전하지는 않다.

### 코틀린 컬렉션과 자바
모든 코틀린 컬렉션은 그에 상응하는 자바 컬렉션 인터페이스의 인스턴스라 코틀린과 자바 사이를 오갈 때 아무 변환도 필요 없다.
단, 자바는 읽기 전용 컬렉션과 변경 가능 컬렉션을 구분하지 않으므로, 코틀린에서 읽기 전용으로 선언된 컬렉션이라도 자바 코드에서는 그 컬렉션 객체의 내용을 변경할 수 있다.

### 객체의 배열과 원시 타입의 배열
코틀린에서 배열 만드는 방법
* arrayOf()
* arrayOfNulls()에 정수 값 n을 인자로 넘기면 모든 원소가 null인 n사이즈의 배열을 만들 수 있다.
* Array 생성자는 배열 크기와 람다를 인자로 받아서 람다를 호출해서 각 배열 원소를 초기화 해준다.

toTypedArray 메서드를 사용하면 쉽게 컬렉션을 배열로 바꿀 수 있다.
여기에 vararg 인자를 넘기기 위해서는 스프레드 연산자(*)를 써야 한다.
