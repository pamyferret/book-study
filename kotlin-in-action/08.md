# 고차 함수: 파라미터와 반환 값으로 람다 사용
## 고차 함수 정의
* 고차 함수: 다른 함수를 인자로 받거나 함수를 반환하는 함수

### 함수 타입
```
val sum: (Int, Int) -> Int? = { x, y -> x + y } // null도 지정 가능
val action: () -> Unit = { println(42) }
```

함수 타입 전체가 널이 될 수 있는 타입임을 선언하기 위해서는 함수 타입을 괄호로 감싸고 그 뒤에 물음표를 붙여야 한다.
```
var funOrNull: ((Int, Int) -> Int?) = null
```

함수 타입에서 파라미터 이름을 지정할 수도 있다.
이 때 함수를 정의하는 곳에서 지정한 이름(code, content)를 쓸 수도 있고 원하는 다른 이름을 붙여서 사용할 수도 있다.
```
fun performRequest(
  url: String,
  callback: (code: Int, content: String) -> Unit
) {
  ...
}
```

### 인자로 받은 함수 호출
```
fun twoAndThree(operation: (Int, Int) -> Int) {
  val result = operation(2, 3)
  println("The result is $result")
}
```

### 자바에서 코틀린 함수 타입 사용
컴파일된 코드 안에서 함수 타입은 일반 인터페이스로 바뀐다.
즉 함수 타입의 변수는 FunctionN 인터페이스를 구현하는 객체를 저장한다.
이 때 N은 인자 개수를 의미한다.
* Function0<R> = 인자 없는 함수
* Function1<P1, R> = 인자가 하나인 함수

각 인터페이스 안에는 invoke 메서드 정의가 하나 들어 있어 그것을 호출하면 함수를 실행할 수 있다.
```
// 코틀린
fun processTheAnswer(f: (Int) -> Int) {
  println(f(42))
}

// 자바
processTheAnswer(
  new Function1<Integer, Integer>() {
    @Override
    public Integer invoke(Integer number) {
      System.out.println(number);
      return number + 1;
    }
  }
);
```

### 디폴트 값을 지정한 함수 타입 파라미터나 널이 될 수 있는 함수 타입 파라미터
파라미터를 함수 타입으로 선언할 때도 디폴트 값을 정할 수 있다.

### 함수를 함수에서 반환
보통은 함수를 인자로 받는 경우가 많지 함수를 반환하는 경우는 많지 않다.
하지만, 사용자가 선택한 배송 수단에 따라 배송비를 계산하는 방법이 다를 경우 배송 수단에 따라 계산하는 식(함수)를 반환하게 할 수도 있다.
함수를 반환하려면 return 식에 람다나 멤버 참고나 함수 타입의 값을 계산하는 식 등을 넣으면 된다.

### 람다를 활용한 중복 제거
코드의 일부분을 중복되는 경우가 있다면 그 코드를 람다로 만들면 중복을 제거할 수 있다.

## 인라인 함수: 람다의 부가 비용 없애기
코틀린은 보통 람다를 무명 클래스로 컴파일 하지만 그렇다고 람다 식을 사용할 때마다 새로운 클래스가 만들어지지는 않는다.
람다가 변수를 포획한 경우에만 람다가 생성되는 시점마다 새로운 무명 클래스가 생긴다.
여튼 이러한 경우들에서 실행 시점에 무명 클래스 생성에 따른 부가 비용이 든다.
따라서 람다를 사용하는 구현은 똑같은 작업을 수행하는 일반 함수를 사용한 구현보다 덜 효율적이다.

### 인라이닝이 작동하는 방식
어떤 함수를 inline으로 선언하면 컴파일러는 그 함수를 호출하는 모든 문장을 함수 본문에 해당하는 바이트코드로 바꿔치기 해준다.
이 때 람다의 본문에 의해 만들어지는 바이트코드는 그 람다를 호출하는 코드 정의의 일부분으로 간주되기 때문에 무명 클래스로 감싸지 않고 함수 본문과 같이 인라이닝된다.
(람다 외부의 변수를 람다 내에서 쓴 경우는 제외)

### 인라인 함수의 한계
일반적으로 인라인 함수의 본문에서 람다 식을 바로 호출하거나 람다 식을 인자로 전달받아 바로 호출하는 경우에는 그 람다를 인라이닝할 수 있다.
그런 경우가 아니라면 컴파일러는 "Illegal usage of inline-parameter"라는 에러를 발생시킨다.

둘 이상의 람다를 인자로 받는 함수에서 일부 람다만 인라이닝하고 있을 때도 있다.
(예를 들어 어떤 람다에 너무 많은 코드가 들어가거나 어떤 람다에 인라이닝을 하면 안 되는 코드가 들어갈 가능성이 있는 경우)
그럴 때는 noinline 변경자를 사용하면 된다.
```
inline fun foo(inlined: () -> Unit, noinline notInlined: () -> Unit) {
  ...
}
```

### 컬렉션 연산 인라이닝
filter, map등 컬렉션 함수는 인라인 함수이다. 따라서 성능에 이슈가 없다.
하지만 아래와 같이 filter, map을 연속해서 쓰는 경우 중간 결과를 저장하는 중간 리스트가 생성된다.
```
people.filter { it.age > 30 }
        .map(Person::name)
```

asSequence를 통해 중간 리스트로 인한 부가 비용을 줄일 수 있지만 각 중간 시퀀스는 람다를 필드에 저장하는 객체로 표현되며, 최종 연산은 중간 시퀀스에 있는 여러 람다를 연쇄 호출하는 식으로 구현된다.
따라서 시퀀스는 람다를 저장해야하므로 람다를 인라이닝하지 않는다.
이로인해 지연 계산을 통해 성능을 향상 시킨다는 이유로 모든 컬렉션 연산에 asSequence를 붙여서는 안 된다.
(크기가 작은 컬렉션은 인라이닝을 할 수 있게 asSequence를 사용하는게 더 성능이 나을 수 있음)

### 함수를 인라인으로 선언해야 하는 경우
인라이닝의 장점은 아래와 같다.
* 함수 호출 비용을 줄일 수 있을 뿐 아니라 람다를 표현하는 클래스와 람다 인스턴스에 해당하는 객체를 만들 필요가 없다.
* 현재 JVM은 함수 호출과 람다를 인라이닝해줄 정도로 똑똑하지 못하다
* 인라이닝을 사용하면 일반 람다에서 사용할 수 없는 몇 가지 기능이 있다. (non-local 반환 등)

단, 인라이닝하는 함수가 큰 경우 함수의 본문에 해당하는 바이트코드를 모든 호출 지점에 복사해 바이트코드가 아주 커질 수 있다.

### 자원 관리를 위해 인라인된 람다 사용
```
val l: Lock = ...
l.withLock {
  // 락에 의해 보호되는 자원을 사용한다.
}
```

자바에서 제공하는 try-with-resource문에 대응하는 코틀린 use 함수
use 함수는 닫을 수 있는(closeable) 자원에 대한 확장 함수이다.
이 때 람다 안에서 예외가 발생한 경우에도 자원을 확실히 닫는다.
또한 use 함수도 인라인 함수이다.
```
fun readFirstLineFromFile(path: String): String {
  BufferedReader(FileReader(path)).use { br ->
    return br.readLine() // non-local return(람다가 아니라 readFirstLineFromFirst 함수를 끝내면서 값을 반환함
  }
}
```

## 고차 함수 안에서 흐름 제어
### 람다 안의 return문: 람다를 둘러싼 함수로부터 반환
인라인 함수가 람다를 인자로 받는 경우 람다 안에서 return을 사용하면 람다로부터만 반환되는게 아니라 그 람다를 호출하는 함수가 실행을 끝내고 반환하게 한다.
* non-local return: 자신을 둘러싸고 있는 블록보다 더 바깥에 있는 다른 블록을 반환하게 만드는 return 문

### 람다로부터 반환: 레이블을 사용한 return
```
fun lookForAlice(people: List<Person>) {
  people.forEach label@ {
    if (it.name == "Alice") return@label
  }
  println("Alice might be somewhere")
}
```

람다에 레이블을 붙여서 사용하는 대신 람다를 인자로 받는 인라인 함수의 이름을 return 뒤에 레이블로 사용해도 된다.
```
fun lookForAlice(people: List<Person>) {
  people.forEach {
    if (it.name == "Alice") return @forEach
  }
}
```

함수 이름을 에리블로 사용할 수 없으며 람다 식에는 레이블이 2개 이상 붙을 수 없다.

### 무명 함수: 기본적으로 로컬 return
무명 함수 안에서 레이블이 붙지 않은 return 식은 무명 함수 자체를 반환시킬 뿐 무명 함수를 둘러싼 다른 함수를 반환시키지 않는다.
람다 식은 fun을 사용하지 않으므로 람다 본문의 return은 람다 밖의 함수를 반환시키고 무명 함수는 fun을 사용해 정의 되므로 return시 자신을 반환한다.
